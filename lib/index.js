!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var s=e();for(var a in s)("object"==typeof exports?exports:t)[a]=s[a]}}(self,(()=>(()=>{"use strict";var t={d:(e,s)=>{for(var a in s)t.o(s,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:s[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{DictContainer:()=>n,Dictionary:()=>i,PageStatus:()=>h,dictContainer:()=>o});const s=Array.isArray,a=t=>t instanceof Map,r=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new WeakMap;if(null===t||"object"!=typeof t)return t;if(e.has(t))return e.get(t);if(t instanceof Date)return new Date(t);if(t instanceof RegExp)return new RegExp(t.source,t.flags);if("function"==typeof t)return t.bind({});if(t instanceof Map){const s=new Map;return e.set(t,s),t.forEach(((t,a)=>{s.set(a,r(t,e))})),s}if(t instanceof Set){const s=new Set;return e.set(t,s),t.forEach((t=>{s.add(r(t,e))})),s}if(Array.isArray(t)){const s=[];return e.set(t,s),t.forEach(((t,a)=>{s[a]=r(t,e)})),s}const s={};return e.set(t,s),Object.keys(t).forEach((a=>{s[a]=r(t[a],e)})),s};class i{#t;#e;#s=(()=>new Map)();constructor(t){this.#t=t,this.#a(t)}getVal(t){return this.#e.get(t)}values(){return Array.from(this.#e.values())}keys(){return Array.from(this.#e.keys())}getKey(t){for(let[e,s]of this.#e.entries())if(s===t)return e}hasValue(t){for(let e of this.values())if(e===t)return!0;return!1}getRaw(){return r(this.#t)}#a(t){if(a(t))this.#e=t;else if(s(t))this.#e=new Map(t);else{if("object"!=typeof(e=t)||null===e)throw new Error("type of data is invalid");this.#e=i.toMap(t)}var e}addLink(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=s?this[s]?.(e):e;this.#s.set(t,new i(a))}getLink(t){if(!this.#s.has(t))throw new Error("linkMap has no key:",t);return this.#s.get(t)}getLinkVal(t,e){return this.linkOf(t).getVal(e)}byDefaultSequence(t){return this.values().map(((e,s)=>[e,t[s]]))}static toMap(t){return a(t)?t:new Map(Object.entries(t))}[Symbol.iterator](){return this.#e[Symbol.iterator]()}}class n{#r=(()=>new Map)();getDict(t){if(!this.#r.has(t))throw new Error(`dictionary ${t} is not exist`);return this.#r.get(t)}addDict(t,e){if(this.#r.has(t))throw new Error(`dictionary ${t} is already exist`);this.#r.set(t,new i(e))}}const o=new n,u="ADD",l="EDIT",f="CHECK",p=[[u,u],[l,l],[f,f]];class h{status;statusMap;constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.status=t,this.statusMap=new Map(p)}changeStatus(t){if(!this.statusMap.has(t))throw new Error(`${t} is not a valid status`);this.status=this.statusMap.get(t)}isStatus(t){return this.status===this.statusMap.get(t)}fetchStatus(t){return t.some((t=>this.isStatus(t)))}get status(){return this.status}get isAdd(){return this.isStatus(u)}get isEdit(){return this.isStatus(l)}get isCheck(){return this.isStatus(f)}get statusEnum(){return this.statusMap}}return e})()));